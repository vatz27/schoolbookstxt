C h a p t e r Data Handling Using 2 Pandas - I “If you don't think carefully, you might believe that programming is just typing statements in a programming language.” —  W. Cunningham In this chapter » Introduction to Python Libraries 2.1 IntroductIon to Python LIbrarIes » Series Python libraries contain a collection of built- » DataFrame in modules that allow us to perform many actions without writing detailed programs » Importing and Exporting Data for it. Each library in Python contains a large between CSV Files number of modules that one can import and and DataFrames use.  » Pandas Series Vs NumPy, Pandas and Matplotlib are three NumPy ndarray well-established Python libraries for scientific and analytical use. These libraries allow us to manipulate, transform and visualise data easily and efficiently. NumPy, which stands for ‘Numerical Python’, is a library we discussed in class XI. Recall that, it is a package that can be used for numerical data analysis and 2024-25 Chapter 2.indd   27 11/26/2020   12:32:46 PM 28 InformatIcs PractIces notes scientific computing. NumPy uses a multidimensional array object and has functions and tools for working with these arrays.  Elements of an array stay together in memory, hence, they can be quickly accessed. PANDAS (PANel DAta) is a high-level data manipulation tool used for analysing data. It is very easy to import and export data using Pandas library which has a very rich set of functions. It is built on packages like NumPy and Matplotlib and gives us a single, convenient place to do most of our data analysis and visualisation work. Pandas has three important data structures, namely – Series, DataFrame and Panel to make the process of analysing data organised, effective and efficient. The Matplotlib library in Python is used for plotting graphs and visualisation. Using Matplotlib, with just a few lines of code we can generate publication quality plots, histograms, bar charts, scatterplots, etc. It is also built on Numpy, and is designed to work well with Numpy and Pandas. You may think what the need for Pandas is when NumPy can be used for data analysis. Following are some of the differences between Pandas and Numpy: 1. A Numpy array requires homogeneous data, while a Pandas DataFrame can have different data types (float, int, string, datetime, etc.). 2. Pandas have a simpler interface for operations like file loading, plotting, selection, joining, GROUP BY, which come very handy in data-processing applications. 3. Pandas DataFrames (with column names) make it very easy to keep track of data. 4. Pandas is used when data is in Tabular Format, whereas Numpy is used for numeric array based data manipulation. 2.1.1. Installing Pandas Installing Pandas is very similar to installing NumPy. To install Pandas from command line, we need to type in: pip install pandas Note that both NumPy and Pandas can be installed only when Python is already installed on that system. The same is true for other libraries of Python. 2024-25 Chapter 2.indd   28 11/26/2020   12:32:46 PM Data HanDling Using PanDas - i 29 2.1.2. Data Structure in Pandas A data structure is a collection of data values and operations that can be applied to that data. It enables efficient storage, retrieval and modification to the data. For example, we have already worked with a data structure ndarray in NumPy in Class XI. Recall the ease with which we can store, access and update data using a NumPy array. Two commonly used data structures in Pandas that we will cover in this book are: • Series • DataFrame 2.2 serIes A Series is a one-dimensional array containing a sequence of values of any data type (int, float, list, string, etc) which by default have numeric data labels starting from zero. The data label associated with a particular value is called its index. We can also assign values of other data types as index. We can imagine a Pandas Series as a column in a spreadsheet. Example of a series containing names of students is given below: Index Value 0  Arnab 1  Samridhi 2  Ramit 3  Divyam 4  Kritika 2.2.1 Creation of Series There are different ways in which a series can be created in Pandas. To create or use series, we first need to import the Pandas library. (A) Creation of Series from Scalar Values A Series can be created using scalar values as shown in the example below: >>> import pandas as pd   #import Pandas with alias pd >>> series1 = pd.Series([10,20,30])  #create a Series >>> print(series1)  #Display the series Output: 0    10 1    20 2    30 dtype: int64 2024-25 Chapter 2.indd   29 11/26/2020   12:32:46 PM 30 InformatIcs PractIces Observe that output is shown in two columns -  the index is on the left and the data value is on the right. If we do not explicitly specify an index for the data values while creating a series, then by default indices range from 0 through N –  1. Here N is the number of data elements. We can also assign user-defined labels to the index and use them to access elements of a Series. The Activity 2.1 following example has a numeric index in random order. Create a series having names of any five >>> series2 = pd.Series(["Kavi","Shyam","Ra famous monuments of vi"], index=[3,5,1]) India and assign their >>> print(series2)  #Display the series States as index values. Output: 3     Kavi 5    Shyam 1     Ravi dtype: object Here, data values Kavi, Shyam and Ravi have index values 3, 5 and 1, respectively. We can also use letters or strings as indices, for example: >>> series2 = pd.Series([2,3,4],index=["Feb","M ar","Apr"]) >>> print(series2) #Display the series Think and Reflect Output: Feb    2 While importing Mar    3 Pandas, is it Apr    4 mandatory to always dtype: int64 use pd as an alias name? What would happen if we give any Here, data values 2,3,4 have index values Feb, Mar other name? and Apr, respectively. (B) Creation of Series from NumPy Arrays We can create a series from a one-dimensional (1D) NumPy array, as shown below: >>> import numpy as np  # import NumPy with alias np >>> import pandas as pd >>> array1 = np.array([1,2,3,4]) >>> series3 = pd.Series(array1) >>> print(series3) Output: 0    1 1    2 2    3 3    4 dtype: int32 2024-25 Chapter 2.indd   30 11/26/2020   12:32:47 PM Data HanDling Using PanDas - i 31 The following example shows that we can use letters notes or strings as indices: >>> series4 = pd.Series(array1, index = ["Jan", "Feb", "Mar", "Apr"]) >>> print(series4) Jan    1 Feb    2 Mar    3 Apr    4 dtype: int32 When index labels are passed with the array, then the length of the index and array must be of the same size, else it will result in a ValueError. In the example shown below, array1 contains 4 values whereas there are only 3 indices, hence ValueError is displayed. >>> series5 = pd.Series(array1, index = ["Jan", "Feb", "Mar"]) ValueError: Length of passed values is 4, index implies 3 (C) Creation of Series from Dictionary Recall that Python dictionary has key: value pairs and a value can be quickly retrieved when its key is known. Dictionary keys can be used to construct an index for a Series, as shown in the following example. Here, keys of the dictionary dict1 become indices in the series. >>> dict1 = {'India': 'NewDelhi', 'UK': 'London', 'Japan': 'Tokyo'} >>> print(dict1)  #Display the dictionary {'India': 'NewDelhi', 'UK': 'London', 'Japan': 'Tokyo'} >>> series8 = pd.Series(dict1) >>> print(series8)  #Display the series India    NewDelhi UK         London Japan       Tokyo dtype: object 2.2.2 Accessing Elements of a Series There are two common ways for accessing the elements of a series: Indexing and Slicing. (A) Indexing Indexing in Series is similar to that for NumPy arrays, and is used to access elements in a series. Indexes are of two types: positional index and labelled index. Positional index takes an integer value that corresponds to its position in the series starting from 0, whereas labelled index takes any user-defined label as index. 2024-25 Chapter 2.indd   31 11/26/2020   12:32:47 PM 32 InformatIcs PractIces • Following example shows usage of the positional index for accessing a value from a Series. >>> seriesNum = pd.Series([10,20,30]) >>> seriesNum[2] 30 Here, the value 30 is displayed for the positional index 2. When labels are specified, we can use labels as indices while selecting values from a Series, as shown below. Here, the value 3 is displayed for the labelled index Mar. >>> seriesMnths = pd.Series([2,3,4],index=["Feb ","Mar","Apr"]) >>> seriesMnths["Mar"] 3 In the following example, value NewDelhi is displayed for the labelled index India. >>> seriesCapCntry = pd.Series(['NewDelhi', 'WashingtonDC', 'London', 'Paris'], index=['India', 'USA', 'UK', 'France']) Activity 2.2 >>> seriesCapCntry['India'] 'NewDelhi' Write the statement to get NewDelhi as output We can also access an element of the series using using positional index. the positional index: >>> seriesCapCntry[1] 'WashingtonDC' More than one element of a series can be accessed using a list of positional integers or a list of index labels as shown in the following examples: >>> seriesCapCntry[[3,2]] France     Paris UK        London dtype: object >>> seriesCapCntry[['UK','USA']] UK           London USA    WashingtonDC dtype: object The index values associated with the series can be altered by assigning new index values as shown in the following example: >>> seriesCapCntry.index=[10,20,30,40] >>> seriesCapCntry 2024-25 Chapter 2.indd   32 11/26/2020   12:32:47 PM Data HanDling Using PanDas - i 33 10        NewDelhi 20    WashingtonDC 30          London 40           Paris dtype: object (B) Slicing Sometimes, we may need to extract a part of a series. This can be done through slicing. This is similar to slicing used with NumPy arrays. We can define which part of the series is to be sliced by specifying the start and end parameters [start :end] with the series name. When we use positional indices for slicing, the value at the endindex position is excluded, i.e., only (end start) number of data values of the series are extracted. Consider the following series seriesCapCntry: >>> seriesCapCntry = pd.Series(['NewDelhi', 'WashingtonDC', 'London', 'Paris'], index=['India', 'USA', 'UK', 'France']) >>> seriesCapCntry[1:3] #excludes the value at index position 3 USA    WashingtonDC UK           London dtype: object As we can see that in the above output, only data values  at indices 1 and 2 are displayed. If labelled indexes are used for slicing, then value at the end index label is also included in the output, for example: >>> seriesCapCntry['USA' : 'France'] USA       WashingtonDC UK              London France           Paris dtype: object We can also get the series in reverse order, for example: >>> seriesCapCntry[ : : -1] France           Paris UK              London USA       WashingtonDC India         NewDelhi dtype: object 2024-25 Chapter 2.indd   33 11/26/2020   12:32:47 PM 34 InformatIcs PractIces notes We can also use slicing to modify the values of series elements as shown in the following example: >>> import numpy as np >>> seriesAlph = pd.Series(np.arange(10,16,1), index = ['a', 'b', 'c', 'd', 'e', 'f']) >>> seriesAlph a    10 b    11 c    12 d    13 e    14 f    15 dtype: int32 >>> seriesAlph[1:3] = 50 >>> seriesAlph a    10 b    50 c    50 d    13 e    14 f    15 dtype: int32 Observe that updating the values in a series using slicing also excludes the value at the end index position. But, it changes the value at the end index label when slicing is done using labels. >>> seriesAlph['c':'e'] = 500 >>> seriesAlph a     10 b     50 c    500 d    500 e    500 f     15 dtype: int32 2.2.3 Attributes of Series We can access certain properties called attributes of a series by using that property with the series name. Table 2.1 lists some attributes of Pandas series usingseriesCapCntry as an example: >>> seriesCapCntry India         NewDelhi USA       WashingtonDC UK              London France           Paris dtype: object 2024-25 Chapter 2.indd   34 11/26/2020   12:32:47 PM Data HanDling Using PanDas - i 35 Table 2.1 Attributes of Pandas Series Attribute Name Purpose Example name assigns a name to the Series >>> seriesCapCntry.name = ‘Capitals’ >>> print(seriesCapCntry) India         NewDelhi USA       WashingtonDC UK              London France           Paris Name: Capitals, dtype: object index.name assigns a name to the index >>>seriesCapCntry.index.name = of the series ‘Countries’ >>> print(seriesCapCntry) Countries India         NewDelhi USA       WashingtonDC UK              London France           Paris Name: Capitals, dtype: object values prints a list of the values in >>> print(seriesCapCntry.values) the series [‘NewDelhi’ ‘WashingtonDC’ ‘London’ ‘Paris’] size prints the number of values >>> print(seriesCapCntry.size) in the Series object 4 empty prints True if the series is >>> seriesCapCntry.empty empty, and False otherwise False # Create an empty series seriesEmpt=pd.Series() >>> seriesEmpt.empty True 2.2.4 Methods of Series Activity 2.3 In this section, we are going to discuss some of the methods that are available for Pandas Series. Let us Consider the following code: consider the following series: >>>import pandas as pd >>>import numpy as np >>> seriesTenTwenty=pd.Series(np.arange( 10, >>>s2=pd. 20, 1 )) Series([12,np.nan,10]) >>> print(seriesTenTwenty) >>>print(s2) 0    10 1    11 Find output of the 2    12 above code and write 3    13 a Python statement to 4    14 count and display only 5    15 non null values in the 6    16 7    17 above series. 8    18 9    19 dtype: int32 2024-25 Chapter 2.indd   35 11/26/2020   12:32:47 PM 36 InformatIcs PractIces Method Explanation Example head(n) Returns the first n members of the series.  If >>> seriesTenTwenty.head(2) the value for n is not passed, then by default 0    10 n takes 5 and the first five members are 1    11 displayed. dtype: int32 >>> seriesTenTwenty.head() 0    10 1    11 2    12 3    13 4    14 dtype: int32 count() Returns the number of non-NaN values in >>> seriesTenTwenty.count() the Series 10 tail(n) Returns the last n members of the series. If >>> seriesTenTwenty.tail(2) the value for n is not passed, then by default 8    18 n takes 5 and the last five members are 9    19 displayed. dtype: int32 >>> seriesTenTwenty.tail() 5    15 6    16 7    17 8    18 9    19 dtype: int32 2.2.5 Mathematical Operations on Series We have learnt in Class XI that if we perform basic mathematical operations like addition, subtraction, multiplication, division, etc., on two NumPy arrays, the operation is done on each corresponding pair of elements. Similarly, we can perform mathematical operations on two series in Pandas. While performing mathematical operations on series, index matching is implemented and all missing values are filled in with NaN by default. Consider the following series: seriesA and seriesB for understanding mathematical operations on series in Pandas. >>> seriesA = pd.Series([1,2,3,4,5], index = ['a', 'b', 'c', 'd', 'e']) >>> seriesA a    1 b    2 c    3 d    4 e    5 dtype: int64 2024-25 Chapter 2.indd   36 11/26/2020   12:32:47 PM Data HanDling Using PanDas - i 37 >>> seriesB = pd.Series([10,20,-10,-50,100], notes index = ['z', 'y', 'a', 'c', 'e']) >>> seriesB z     10 y     20 a    -10 c    -50 e    100 dtype: int64 (A) Addition of two Series It can be done in two ways. In the first method, two series are simply added together, as shown in the following code. Table 2.2 shows the detailed values that were matched while performing the addition. Note here that the output of addition is NaN if one of the elements or both elements have no value. >>> seriesA + seriesB a     -9.0 b      NaN c    -47.0 d      NaN e    105.0 y      NaN z      NaN dtype: float64 Table 2.2 Details of addition of two series index value from value from seriesA + seriesB seriesA seriesB a 1 -10 -9.0 b 2 NaN c 3 -50 -47.0 d 4 NaN e 5 100 105.00 y 20 NaN z 10 NaN The second method is applied when we do not want to have NaN values in the output. We can use the series method add() and a parameter fill_value to replace missing value with a specified value. That is, calling seriesA.add(seriesB) is equivalent to calling seriesA+seriesB, but add() allows explicit specification of the fill value for any element in seriesA or seriesB that might be missing, as shown in Table 2.3. 2024-25 Chapter 2.indd   37 11/26/2020   12:32:47 PM 38 InformatIcs PractIces >>> seriesA.add(seriesB, fill_value=0) Activity 2.4 a     -9.0 b      2.0 Draw two tables for c    -47.0 subtraction similar d      4.0 to tables 2.2 and 2.3 e    105.0 showing the changes in y     20.0 the series elements and z     10.0 corresponding output dtype: float64 without replacing the missing values, and Table 2.3 Details of addition of two series using add() method after replacing the index value from value from seriesA + seriesB missing values with seriesA seriesB 1000. a 1 -10 -9.0 b 2 0 2.0 c 3 -50 -47.0 d 4 0 4.0 e 5 100 105.00 y 0 20 20.0 z 0 10 10.0 Note that Table 2.2 shows the changes in the series elements and corresponding output without replacing the missing values, while Table 2.3 shows the changes in the series elements and corresponding output after replacing missing values by 0. Just like addition, subtraction, multiplication and division can also be done using corresponding mathematical operators or explicitly calling of the appropriate method. (B) Subtraction of two Series Again, it can be done in two different ways, as shown in Activity 2.5 the following examples: Draw two tables for >>> seriesA – seriesB #using subtraction operator multiplication similar a     11.0 to Tables 2.2 and 2.3 b     NaN showing the changes c     53.0 in the series elements d     NaN and corresponding output without e     -95.0 replacing the missing y     NaN values, and after z     NaN replacing the missing dtype: float64 values with 0. Let us now replace the missing values with 1000 before subtracting seriesB from seriesA using explicit subtraction method sub(). 2024-25 Chapter 2.indd   38 11/26/2020   12:32:47 PM Data HanDling Using PanDas - i 39 >>> seriesA.sub(seriesB, fill_value=1000) # using fill value 1000 while making explicit # call of the method” a     11.0 b     -998.0 c     53.0 d     -996.0 e     -95.0 y     980.0 z     990.0 dtype: float64 (C) Multiplication of two Series Again, it can be done in two different ways, as shown in the following examples: >>>seriesA * seriesB #using multiplication operator a    -10.0 b      NaN c   -150.0 d      NaN e    500.0 y      NaN z      NaN dtype: float64 Let us now replace the missing values with 0 before Activity 2.6 multiplication of seriesB with seriesA using explicit multiplication method mul(). Draw two tables for division similar to >>> seriesA.mul(seriesB, fill_value=0) tables 2.2 and 2.3 # using fill value 0 while making showing the changes #explicit call of the method in the series elements a    -10.0 and corresponding b      0.0 output without c   -150.0 replacing the missing d      0.0 values, and after e    500.0 replacing the missing y      0.0 values with 0. z      0.0 dtype: float64 (D) Division of two Series Again, it can be done in two different ways, as shown in Explicit call to the following examples: a mathematical operation is preferred >>> seriesA/seriesB  # using division operator when series may have a    -0.10 missing values and we b     NaN want to replace it by a c     -0.06 specific value to have d     NaN a concrete output in place of NaN. 2024-25 Chapter 2.indd   39 11/26/2020   12:32:47 PM 40 InformatIcs PractIces e     0.05 y     NaN z     NaN dtype: float64 Let us now replace the missing values with 0 before dividing seriesA by seriesB using explicit division method div(). # using fill value 0 while making explicit # call of the method a    -0.10 b     inf c    -0.06 d     inf e     0.05 y     0.00 z     0.00 dtype: float64 2.3 dataFrame Sometimes we need to work on multiple columns at a time, i.e., we need to process the tabular data. For example, the result of a class, items in a restaurant’s menu, reservation chart of a train, etc. Pandas store such tabular data using a DataFrame. A DataFrame is a two-dimensional labelled data structure like a table of MySQL. It contains rows and columns, and therefore has both a row and column index. Each column can have a different type of value such as numeric, string, boolean, etc., as in tables of a database. Column Indexes State Geographical Area Area under Very (sq Km) Dense Forests (sq Km) 1 Assam 78438 2797 2 Delhi 1483 6.72 3 Kerala 38852 1663 2.3.1 Creation of DataFrame There are a number of ways to create a DataFrame. Some of them are listed in this section. (A) Creation of an empty DataFrame An empty DataFrame can be created as follows: 2024-25 Chapter 2.indd   40 11/26/2020   12:32:47 PM Row Indexes Data HanDling Using PanDas - i 41 >>> import pandas as pd >>> dFrameEmt = pd.DataFrame() Think and Reflect >>> dFrameEmt What would happen if Empty DataFrame we pass 3 columns or Columns: [] 5 columns instead of Index: [] 4 in the above code? What is the reason? (B) Creation of DataFrame from NumPy ndarrays Consider the following three NumPy ndarrays. Let us create a simple DataFrame without any column labels, using a single ndarray: >>> import numpy as np >>> array1 = np.array([10,20,30]) >>> array2 = np.array([100,200,300]) >>> array3 = np.array([-10,-20,-30, -40]) >>> dFrame4 = pd.DataFrame(array1) >>> dFrame4 0 0  10 1  20 2  30 We can create a DataFrame using more than one ndarrays, as shown in the following example: >>> dFrame5 = pd.DataFrame([array1, array3, array2], columns=[ 'A', 'B', 'C', 'D']) >>> dFrame5 A    B    C     D 0   10   20   30   NaN 1  -10  -20  -30 -40.0 2  100  200  300   NaN (C) Creation of DataFrame from List of Dictionaries We can create DataFrame from a list of Dictionaries, for example: # Create list of dictionaries >>> listDict = [{'a':10, 'b':20}, {'a':5, 'b':10, 'c':20}] >>> dFrameListDict = pd.DataFrame(listDict) >>> dFrameListDict a   b     c 0  10  20   NaN 1   5  10  20.0 Here, the dictionary keys are taken as column labels, and the values corresponding to each key are taken as rows. There will be as many rows as the number of dictionaries present in the list. In the above example there are two dictionaries in the list. So, the DataFrame consists of two rows. Number of columns 2024-25 Chapter 2.indd   41 11/26/2020   12:32:47 PM 42 InformatIcs PractIces in a DataFrame is equal to the maximum number of keys in any dictionary of the list. Hence, there are three columns as the second dictionary has three elements. Also, note that NaN (Not a Number) is inserted if a corresponding value for a column is missing. (D) Creation of DataFrame from Dictionary of Lists DataFrames can also be created from a dictionary of lists. Consider the following dictionary consisting of the keys ‘State’, ‘GArea’ (geographical area) and ‘VDF’ (very dense forest) and the corresponding values as list. >>> dictForest = {'State': ['Assam', 'Delhi', 'Kerala'], 'GArea': [78438, 1483, 38852] , 'VDF' : [2797, 6.72,1663]} >>> dFrameForest= pd.DataFrame(dictForest) >>> dFrameForest State   GArea    VDF 0   Assam   78438  2797.00 1   Delhi   1483     6.72 2   Kerala  38852  1663.00 Note that dictionary keys become column labels by default in a DataFrame, and the lists become the rows. Thus, a DataFrame can be thought of as a dictionary of lists or a dictionary of series. We can change the sequence of columns in a DataFrame. This can be done by assigning a particular sequence of the dictionary keys as columns parameter, for example: >>> dFrameForest1 = pd.DataFrame(dictForest, columns = ['State','VDF', 'GArea']) >>> dFrameForest1 State      VDF   GArea 0   Assam   2797.00  78438 1   Delhi     6.72   1483 2   Kerala  1663.00  38852 In the output, VDF is now displayed as the middle column instead of last. (E) Creation of DataFrame from Series Consider the following three Series: seriesA = pd.Series([1,2,3,4,5], index = ['a', 'b', 'c', 'd', 'e']) seriesB = pd.Series ([1000,2000,-1000,-5000,1000], index = ['a', 'b', 'c', 'd', 'e']) 2024-25 Chapter 2.indd   42 11/26/2020   12:32:47 PM Data HanDling Using PanDas - i 43 seriesC = pd.Series([10,20,-10,-50,100], notes index = ['z', 'y', 'a', 'c', 'e']) We can create a DataFrame using a single series as shown below: >>> dFrame6 = pd.DataFrame(seriesA) >>> dFrame6 0 a  1 b  2 c  3 d  4 e  5 Here, the DataFrame dFrame6 has as many numbers of rows as the numbers of elements in the series, but has only one column. To create a DataFrame using more than one series, we need to pass multiple series in the list as shown below: >>> dFrame7 = pd.DataFrame([seriesA, seriesB]) >>> dFrame7 a     b     c     d     e 0     1     2     3     4     5 1  1000  2000 -1000 -5000  1000 Observe that the labels in the series object become the column names in the DataFrame object and each series becomes a row in the DataFrame. Now look at the following example: >>> dFrame8 = pd.DataFrame([seriesA, seriesC]) >>> dFrame8 a    b     c    d      e     z     y 0   1.0  2.0   3.0  4.0    5.0   NaN   NaN